[TOC]

## 01 | 可见性、原子性和有序性问题：并发编程 Bug 的源头

-   为什么并发编程容易出问题呢？它是怎么出问题的？今天，我们就重点聊聊这些 Bug 的源头。

### 并发程序幕后的故事

-   这些年，CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但，有一个核心矛盾一直存在，**就是这三者的速度差异。**
-   根据木桶理论，程序整体的性能取决于最慢的操作——读写 I/O 设备。
-   为了合理利用 CPU 的高性能，**平衡这三者的速度差异**，计算机体系结构、操作系统、编译程序都做了贡献，主要体现为：
    1.  CPU 增加了缓存，以均衡与内存的速度差异。
    2.  操作系统增加了进程、线程，以分时利用CPU，进而均衡 CPU 与 I/O 设备的速度差异。
    3.  编译程序优化指令执行次序，使用缓存能够得到更加合理地利用。

### 源头一：缓存导致的可见性问题

-   单核时代。

    -   因为，所以线程都是操作同一个CPU 的缓存，一个线程对缓存的写，对另一个线程来说一定是可见的。如下图：
    -   ![img](imgs/a07e8182819e2b260ce85b2167d446da-1583769213809.png)
    -   一个线程对共享变量的修改，另一个线程能够立刻看到，我们称为**可见性**。

-   多核时代

    -   当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。
    -   这时，一个线程对共享变量的操作，对于另一个线程而言就不具备可见性了。如下图
    -   ![img](imgs/e2aa76928b2bc135e08e7590ca36e0ea.png)

-   我们用一段代码来验证一下多核场景下的可见性问题。代码如下：

    -   ```java
        
        public class Test {
          private long count = 0;
          private void add10K() {
            int idx = 0;
            while(idx++ < 10000) {
              count += 1;
            }
          }
          public static long calc() {
            final Test test = new Test();
            // 创建两个线程，执行add()操作
            Thread th1 = new Thread(()->{
              test.add10K();
            });
            Thread th2 = new Thread(()->{
              test.add10K();
            });
            // 启动两个线程
            th1.start();
            th2.start();
            // 等待两个线程执行结束
            th1.join();
            th2.join();
            return count;
          }
        }
        ```

    -   实际上，calc() 执行的结果是 10000 到 20000 之间的随机数。

    -   如下图，“变量 count 在 CPU 缓存和内存的分布图”

    -   ![img](imgs/ec6743e74ccf9a3c6d6c819a41e52279.png)

### 源头二：线程切换带来的原子性问题

-   在多进程场景下，操作系统允许某个进程执行一小段时间，如 50ms。过了 50 ms 操作系统就会重新选择另一个进程来执行（“任务切换”），这个 50 ms 称为**时间片**。
    -   如下图，“线程切换示意图”
    -   ![img](imgs/254b129b145d80e9bb74123d6e620efb.png)
-   任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，**高级语言里一条语句往往需要多条 CPU 指令完成**。如上面的 `count += 1`，至少需要三条 CPU 指令。
    1.  首先，需要把变量count 从内在加载到 CPU 的寄存器。
    2.  之后，在寄存器中执行 +1 操作。
    3.  最后，将结果写入内存。（缓存机制导致可能写入的是 CPU 缓存，而不是内存）
-   **操作系统做任务切换，可以发生在任何一条 CPU 指令执行完，是CPU 指令，而不是高级语言里的一条语句。**
    -   如下图，“非原子操作的执行路径示意图”
    -   ![img](imgs/33777c468872cb9a99b3cdc1ff597063.png)
-   **我们把一个或者多个操作在 CPU 执行过程中不被中断的特性称为原子性。**CPU 能保证原子操作是 CPU 指令级别的，而不是高级语言的操作符。因此，很多时候，我们需要在高级语言层面保证操作的原子性。

### 源头三：编译优化带来的有序性问题

-   有序性指的是程序按照代码的先后顺序执行。**编译器为了优化性能，有时会改变程序中语句的先后顺序。**

-   Java 领域一个经典的案例就是“利用双重检查创建单例对象”，代码如下：

    -   ```java
        
        public class Singleton {
          static Singleton instance;
          static Singleton getInstance(){
            if (instance == null) {
              synchronized(Singleton.class) {
                if (instance == null)
                  instance = new Singleton();
                }
            }
            return instance;
          }
        }
        ```

-   看上去一切很完美。但实际上 getInstance() 方法并不完美。问题出在了new 操作上，我们以为的new 操作应该是：

    1.  分配一块内存 M
    2.  在内存 M 上初始化 singleton 对象
    3.  然后 M 的地址赋值给 instance 对象

-   但，实际上，优化后的执行路径却是这样的：

    1.  分配一块内存 M
    2.  将 M 的地址赋值给 instance 对象
    3.  最后在内存 M 上初始化 singleton 对象

-   优化后会导致什么问题呢？

    -   我们假设 A 先执行 getInstance() 方法，当执行完指令 2 时，恰好发生了线程切换，切换到线程 B 上。
    -   如果此时，线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null，所以直接返回 instance，而此时的 instance 是没有初始化的，如果我们这个时候访问 instance 的变量，就可能会触发空指针异常。

-   如下图“双重检查创建单例的异常执行路径”

    -   ![img](imgs/64c955c65010aae3902ec918412827d8.png)

### 总结

-   **只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。**
-   在介绍可见性、原子性、有序性的时候，特意提到**缓存**导致的可见性问题，**线程切换**带来的原子性问题，**编译优化**带来的有序性问题
-   技术在解决一个问题的同时，必然会带来另外一个问题，所以，**在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。**